#include "libft.h"

// Функция для выделения памяти и копирования строки
char *ft_strdup(const char *s) {
    size_t len = strlen(s) + 1; // Добавляем 1 для нулевого символа
    char *dup = (char *)malloc(len);
    if (dup == NULL) {
        return NULL; // Если выделение памяти не удалось
    }
    memcpy(dup, s, len);
    return dup;
}

// Функция для подсчета количества слов в строке
size_t count_words(const char *s, char c) {
    size_t count = 0;
    int in_word = 0; // Флаг, указывающий, находимся ли мы внутри слова
    while (*s) {
        if (*s == c) {
            if (in_word) {
                count++; // Если нашли разделитель и мы были внутри слова, увеличиваем счетчик слов
                in_word = 0;
            }
        } else {
            if (!in_word) {
                in_word = 1; // Если нашли символ, отличный от разделителя, и мы были снаружи слова, устанавливаем флаг in_word в 1
            }
        }
        s++;
    }
    if (in_word) {
        count++; // Добавляем последнее слово, если строка заканчивается не разделителем
    }
    return count;
}

// Функция для освобождения памяти, выделенной для массива строк
void free_split_result(char **result) {
    char **ptr = result;
    while (*ptr) {
        free(*ptr);
        ptr++;
    }
    free(result);
}

// Реализация функции ft_split
char **ft_split(char const *s, char c) {
    // Проверка на пустую строку
    if (s == NULL || *s == '\0') {
        char **empty_result = (char **)malloc(sizeof(char *));
        if (empty_result == NULL) {
            return NULL;
        }
        *empty_result = NULL;
        return empty_result;
    }

    size_t num_words = count_words(s, c);
    char **result = (char **)malloc((num_words + 1) * sizeof(char *)); // +1 для NULL указателя в конце
    if (result == NULL) {
        return NULL; // Если выделение памяти не удалось
    }

    size_t word_index = 0; // Индекс текущего слова в массиве результатов
    size_t word_length = 0; // Длина текущего слова
    const char *word_start = s; // Указатель на начало текущего слова

    while (*s) {
        if (*s == c) {
            if (word_length > 0) {
                // Если длина слова больше нуля, это конец текущего слова
                result[word_index] = ft_strdup(word_start);
                if (result[word_index] == NULL) {
                    free_split_result(result); // Освобождаем ранее выделенную память
                    return NULL;
                }
                word_index++;
                word_length = 0;
            }
            word_start = s + 1; // Перемещаем указатель на начало следующего слова
        } else {
            word_length++;
        }
        s++;
    }

    // Добавляем последнее слово, если строка не заканчивается разделителем
    if (word_length > 0) {
        result[word_index] = ft_strdup(word_start);
        if (result[word_index] == NULL) {
            free_split_result(result); // Освобождаем ранее выделенную память
            return NULL;
        }
        word_index++;
    }

    // Завершаем массив указателем NULL
    result[word_index] = NULL;

    return result;
}


//Эта функция ft_split разделяет строку s с использованием символа-разделителя c и возвращает массив строк, полученных в результате разделения. Если выделение памяти для массива строк или для самих строк не удалось, функция вернет NULL.
